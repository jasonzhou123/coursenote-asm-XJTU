# 微机原理第三章总结笔记

编程错误：
1. 0AFH(注意加零)
2. 注意字节和字匹配
## 1.寻址方式

- 立即数寻址
- 寄存器寻址
- 直接寻址
- 寄存器间接寻址
- 寄存器相对寻址
- 基址变址寻址
- 相对基址变址
- 隐含寻址


---
### 1.1 立即数寻址
立即数寻址本质上很简单，但是需要记住一点，立即数寻址只能在DST

---

### 1.2 寄存器寻址
特点：操作数存放在指令规定的寄存器中
可以使用的对象除了通用寄存器外，也包括了变址寄存器和指针寄存器（SI\DI\BP\SP)，同时也包括了**段寄存器**CS\ES\DS\SS\FS\GS)

### 1.3 直接寻址

特点：

1）操作数有效地址`EA`在指令码之中**直接**给出两字节，操作数本身就在数据段的存储单元中。
（所以EA相当于是这个数字的代号）

2) 默认的段寄存器为`DS`

### 1.4 寄存器间接寻址

特点：操作数`EA`在指令码指定的基址寄存器（BX\BP）,变址寄存器（DI\SI）寄存器中。操作数本身在存储器。

但是BP默认的段基址是SS,它其实是一个比较**灵活变通**的堆栈指针。

注意：**不允许** 使用AX\CX\DX存放EA

### 1.5 寄存器相对寻址

就是在偏移地址上加立即数（这里直接是用的加，结合后文，这里的整体其实就是一个表达式）

### 1.6 基址变址寻址

刚刚谈到了基址寄存器（BX\BP）又有变址寄存器（SI\DI,把两者搭配就成了，然后段基址**取决**于基址段。

1. 功能常用于**表格**和**数组**
2. 还有既然叫做基址变址，所以这两个老哥只能来一类


### 1.7 相对基址变址寻址

相对有“立即数参与”，又有基址变址，然后本质是数据在存储器中，然后，就有了这个巨无霸。

这里的段地址老哥默认的还是`DS`其实猜测对应的是，其实还有一个`ES`,之前一直未出现，它的地位有点像BP, DS对应DATA这个单词，因为后面会有段对应的操作。

格式： MOV AX,SS:COUNTY[BP][SI]

MOV AX,SS:[COUNTY+BP+SI]

MOV AX,SS:COUNTY[BP+SI]



三者皆可

1）堆栈

2）二维数组访问






## 2.程序寻址



## 数据传送指令
1. 取有效地址LEA
格式： LEA reg16, scr
功能： reg<- src

2. 指针传送指令LDS

## 逻辑运算与移位指令

逻辑运算：除了逻辑“非”指令不影响标志外，其他的逻辑运算指令均影响标志SF、ZF和PF，而OF和CF一定被置0，AF不确定。

**TEST** 对两个操作数进行AND操作，但**结果并不送DST**，仅按照AND指令影响标志。



## 算术类指令

### MUL和IMUL

DIV是无符号数的除法，DIV是有符号数的除法

## 串操作指令

#### CX

串，就是连续存放在储存器中的数据，如字节串、字串。

源操作数为DS：[SI];目的操作是ES：[DI]

可加REP/REPZ/REPNZ重复前缀，以重复执行串操作，重复次数放在CX中。

LDS SI





### 控制类指令

1. call
其作用就是调用子程序段。


